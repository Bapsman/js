/**
 * OmegleApp.me Chat Automation Script
 * Paste this into the browser console on https://omegleapp.me/chat/
 *
 * Flow: type message -> send -> skip user -> wait for next -> repeat
 * GUI: Start/Stop + editable message box
 */

(function () {
  // ========== CONFIG ==========
  const FALLBACK_MESSAGE = "";

  // Delays in ms — these are defaults; GUI sliders override them at runtime
  let DELAY_AFTER_INPUT_MS = 600;
  let DELAY_AFTER_SEND = 800;
  let DELAY_AFTER_SKIP = 1500;
  let WAIT_FOR_NEXT_USER_MS = 3000;
  const WAIT_FOR_CHAT_READY_MS = 60000;
  const WAIT_FOR_SEND_ENABLED_MS = 2500;
  const POLL_INTERVAL = 500;

  // ========== SELECTORS (omegleapp.me) ==========
  const selectors = {
    messageInput: ".chatmsg",
    sendBtn: ".sendbtn",
    skipBtn: ".disconnectbtn",
  };

  let stopRequested = false;
  let guiMessageEl = null;
  let guiRepeatEl = null;
  let sentCount = 0;

  function looksLikeScript(text) {
    if (!text || typeof text !== "string") return true;
    const t = text.trim();
    if (t.length > 2000) return true;
    if (/\b(function|=>|const |let |var |startOmegleAuto|OmegleAuto|FALLBACK_MESSAGE)\b/.test(t)) return true;
    if (t.includes("(function ()") && t.includes("})();")) return true;
    return false;
  }

  function log(msg) {
    console.log("[OmegleAuto]", msg);
  }

  function findByText(text) {
    const gui = document.getElementById("omegle-auto-gui");
    const nodes = document.querySelectorAll("button, a, [role='button'], input[type='submit']");
    for (const el of nodes) {
      if (gui && gui.contains(el)) continue; // skip our own GUI buttons
      if (el.textContent && el.textContent.trim().toLowerCase().includes((text || "").toLowerCase()))
        return el;
    }
    return null;
  }

  function getMessageInput() {
    return document.querySelector(selectors.messageInput)
      || document.querySelector("textarea:not(#omegle-auto-msg)")
      || document.querySelector("input[type='text']:not(#omegle-auto-gui input)");
  }

  function getSendButton() {
    const byClass = document.querySelector(selectors.sendBtn);
    if (byClass) {
      const clickable = byClass.tagName === "BUTTON" || byClass.getAttribute("role") === "button"
        ? byClass
        : byClass.querySelector("button, [role='button'], input[type='submit']") || byClass;
      return clickable;
    }
    return findByText("Send") || document.querySelector("button[type='submit']");
  }

  function getSkipButton() {
    return document.querySelector(selectors.skipBtn)
      || findByText("Skip")
      || findByText("New")
      || findByText("Stop");
  }

  function getMessageToSend() {
    if (guiMessageEl) {
      const val = (guiMessageEl.value || "").trim();
      if (val && !looksLikeScript(val)) return val;
    }
    return FALLBACK_MESSAGE;
  }

  function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  function setInputValueReactFriendly(input, value) {
    input.focus();
    const proto = input instanceof HTMLTextAreaElement
      ? window.HTMLTextAreaElement.prototype
      : window.HTMLInputElement.prototype;
    const setter = Object.getOwnPropertyDescriptor(proto, "value");
    if (setter && setter.set) {
      setter.set.call(input, value);
    } else {
      input.value = value;
    }
    input.dispatchEvent(new InputEvent("input", { bubbles: true, data: value, inputType: "insertText" }));
    input.dispatchEvent(new Event("change", { bubbles: true }));
  }

  function dispatchEnterKey(input) {
    const opts = { key: "Enter", code: "Enter", keyCode: 13, which: 13, bubbles: true };
    input.dispatchEvent(new KeyboardEvent("keydown", opts));
    input.dispatchEvent(new KeyboardEvent("keypress", opts));
    input.dispatchEvent(new KeyboardEvent("keyup", opts));
  }

  function waitForChatReady(maxWaitMs) {
    return new Promise((resolve) => {
      const start = Date.now();
      const check = () => {
        if (stopRequested) return resolve(false);
        const input = getMessageInput();
        const sendBtn = getSendButton();
        const skipBtn = getSkipButton();
        const hasInput = input && !input.disabled;
        const hasSend = !!sendBtn;
        const hasSkip = !!skipBtn;
        if (hasInput && (hasSend || hasSkip)) {
          log("Chat ready. Starting send/skip loop.");
          return resolve(true);
        }
        if (Date.now() - start >= maxWaitMs) {
          log("Timeout waiting for chat. Start a chat first, then run the script.");
          return resolve(false);
        }
        setTimeout(check, POLL_INTERVAL);
      };
      check();
    });
  }

  function waitForNextUser(maxWaitMs) {
    return new Promise((resolve) => {
      const start = Date.now();
      const check = () => {
        if (stopRequested) return resolve(false);
        const input = getMessageInput();
        const skipBtn = getSkipButton();
        const hasInput = input && !input.disabled;
        const hasSkip = !!skipBtn;
        if (hasInput && hasSkip) {
          const looking = document.body.textContent.includes("Looking for");
          if (!looking) return resolve(true);
        }
        if (Date.now() - start >= maxWaitMs) return resolve(false);
        setTimeout(check, POLL_INTERVAL);
      };
      check();
    });
  }

  async function sendAndSkip() {
    const input = getMessageInput();
    if (!input) {
      log("Message input not found. Waiting...");
      return false;
    }

    const msg = getMessageToSend();
    if (!msg) {
      log("No message. Set FALLBACK_MESSAGE in the script.");
      return false;
    }

    setInputValueReactFriendly(input, msg);
    await sleep(DELAY_AFTER_INPUT_MS);

    const sendDeadline = Date.now() + WAIT_FOR_SEND_ENABLED_MS;
    let sendBtn = getSendButton();
    while (sendBtn && sendBtn.disabled && Date.now() < sendDeadline) {
      await sleep(100);
      sendBtn = getSendButton();
    }
    if (sendBtn && !sendBtn.disabled) {
      sendBtn.click();
    } else {
      dispatchEnterKey(input);
    }

    sentCount++;
    updateCounter();
    log("Sent #" + sentCount);

    await sleep(DELAY_AFTER_SEND);

    const skipBtn = getSkipButton();
    if (skipBtn) {
      skipBtn.click();
      log("Skipped. Waiting for next user...");
    } else {
      const escOpts = { key: "Escape", code: "Escape", keyCode: 27, which: 27, bubbles: true };
      document.dispatchEvent(new KeyboardEvent("keydown", escOpts));
      log("Sent Escape (skip). Waiting for next user...");
    }

    await sleep(DELAY_AFTER_SKIP);
    return true;
  }

  function updateCounter() {
    const el = document.querySelector("#omegle-auto-counter");
    if (el) el.textContent = "Sent: " + sentCount;
  }

  function resetGuiButtons() {
    const startBtn = document.querySelector("#omegle-auto-start");
    const stopBtn = document.querySelector("#omegle-auto-stop");
    if (startBtn) startBtn.disabled = false;
    if (stopBtn) stopBtn.disabled = true;
  }

  async function runLoop() {
    log("Started. Use Stop button or run stopOmegleAuto() in console.");
    stopRequested = false;

    const ready = await waitForChatReady(WAIT_FOR_CHAT_READY_MS);
    if (!ready || stopRequested) {
      resetGuiButtons();
      return;
    }

    while (!stopRequested) {
      const ok = await sendAndSkip();
      if (!ok) {
        await sleep(POLL_INTERVAL);
        continue;
      }
      // If repeat is off, stop after one cycle
      if (guiRepeatEl && !guiRepeatEl.checked) {
        log("Repeat is off. Finished one cycle.");
        break;
      }
      const found = await waitForNextUser(WAIT_FOR_NEXT_USER_MS);
      if (!found && !stopRequested) await sleep(POLL_INTERVAL);
    }
    log("Stopped.");
    resetGuiButtons();
  }

  window.stopOmegleAuto = function () {
    stopRequested = true;
    log("Stop requested.");
  };

  window.startOmegleAuto = function () {
    runLoop();
  };

  function createGUI() {
    const existing = document.getElementById("omegle-auto-gui");
    if (existing) existing.remove();

    const panel = document.createElement("div");
    panel.id = "omegle-auto-gui";
    panel.innerHTML = `
      <style>
        #omegle-auto-gui {
          position: fixed;
          top: 12px;
          right: 12px;
          width: 280px;
          background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
          border: 1px solid #0f3460;
          border-radius: 10px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          font-family: system-ui, -apple-system, sans-serif;
          font-size: 13px;
          color: #e8e8e8;
          z-index: 999999;
          user-select: none;
        }
        #omegle-auto-gui .gui-header {
          padding: 10px 12px;
          background: rgba(15,52,96,0.5);
          border-radius: 10px 10px 0 0;
          cursor: move;
          font-weight: 600;
          display: flex;
          align-items: center;
          gap: 6px;
        }
        #omegle-auto-gui .gui-header::before { content: "⚡"; }
        #omegle-auto-gui .gui-counter {
          margin-left: auto;
          background: #0d1b2a;
          padding: 2px 8px;
          border-radius: 10px;
          font-size: 11px;
          color: #38ef7d;
          font-weight: 600;
          letter-spacing: 0.3px;
        }
        #omegle-auto-gui .gui-tabs {
          display: flex;
          border-bottom: 1px solid #0f3460;
        }
        #omegle-auto-gui .gui-tab {
          flex: 1;
          padding: 8px 0;
          text-align: center;
          font-size: 12px;
          font-weight: 600;
          color: #6a7a8a;
          cursor: pointer;
          border: none;
          background: none;
          border-bottom: 2px solid transparent;
          transition: color 0.2s, border-color 0.2s;
        }
        #omegle-auto-gui .gui-tab:hover { color: #c0c0c0; }
        #omegle-auto-gui .gui-tab.active {
          color: #e8e8e8;
          border-bottom-color: #3a7bd5;
        }
        #omegle-auto-gui .gui-page { display: none; padding: 12px; }
        #omegle-auto-gui .gui-page.active { display: block; }
        #omegle-auto-gui label {
          display: block;
          margin-bottom: 4px;
          font-size: 11px;
          color: #a0a0a0;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        #omegle-auto-gui textarea {
          width: 100%;
          min-height: 72px;
          padding: 8px 10px;
          margin-bottom: 10px;
          box-sizing: border-box;
          background: #0d1b2a;
          border: 1px solid #1b263b;
          border-radius: 6px;
          color: #e8e8e8;
          font-family: inherit;
          font-size: 13px;
          resize: vertical;
        }
        #omegle-auto-gui textarea:focus {
          outline: none;
          border-color: #3a7bd5;
        }
        #omegle-auto-gui .gui-buttons {
          display: flex;
          gap: 8px;
        }
        #omegle-auto-gui button.btn-start, #omegle-auto-gui button.btn-stop {
          flex: 1;
          padding: 10px 14px;
          border: none;
          border-radius: 6px;
          font-weight: 600;
          font-size: 13px;
          cursor: pointer;
          transition: transform 0.1s, opacity 0.2s;
        }
        #omegle-auto-gui button:active { transform: scale(0.98); }
        #omegle-auto-gui button:disabled { opacity: 0.5; cursor: not-allowed; }
        #omegle-auto-gui .btn-start {
          background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
          color: #0a0a0a;
        }
        #omegle-auto-gui .btn-stop {
          background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
          color: #fff;
        }
        #omegle-auto-gui .gui-toggle {
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-bottom: 10px;
        }
        #omegle-auto-gui .gui-toggle span {
          font-size: 12px;
          color: #c0c0c0;
        }
        #omegle-auto-gui .toggle-switch {
          position: relative;
          width: 40px;
          height: 22px;
          flex-shrink: 0;
        }
        #omegle-auto-gui .toggle-switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }
        #omegle-auto-gui .toggle-slider {
          position: absolute;
          cursor: pointer;
          top: 0; left: 0; right: 0; bottom: 0;
          background: #1b263b;
          border-radius: 22px;
          transition: background 0.2s;
        }
        #omegle-auto-gui .toggle-slider::before {
          content: "";
          position: absolute;
          height: 16px;
          width: 16px;
          left: 3px;
          bottom: 3px;
          background: #a0a0a0;
          border-radius: 50%;
          transition: transform 0.2s, background 0.2s;
        }
        #omegle-auto-gui .toggle-switch input:checked + .toggle-slider {
          background: #11998e;
        }
        #omegle-auto-gui .toggle-switch input:checked + .toggle-slider::before {
          transform: translateX(18px);
          background: #fff;
        }
        #omegle-auto-gui .slider-row {
          margin-bottom: 12px;
        }
        #omegle-auto-gui .slider-label {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 4px;
        }
        #omegle-auto-gui .slider-label span {
          font-size: 12px;
          color: #c0c0c0;
        }
        #omegle-auto-gui .slider-label .slider-val {
          font-size: 11px;
          color: #3a7bd5;
          font-weight: 600;
          min-width: 42px;
          text-align: right;
        }
        #omegle-auto-gui input[type="range"] {
          -webkit-appearance: none;
          appearance: none;
          width: 100%;
          height: 6px;
          background: #1b263b;
          border-radius: 3px;
          outline: none;
          cursor: pointer;
        }
        #omegle-auto-gui input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          border-radius: 50%;
          background: #3a7bd5;
          cursor: pointer;
          border: 2px solid #0d1b2a;
        }
        #omegle-auto-gui input[type="range"]::-moz-range-thumb {
          width: 16px;
          height: 16px;
          border-radius: 50%;
          background: #3a7bd5;
          cursor: pointer;
          border: 2px solid #0d1b2a;
        }
      </style>
      <div class="gui-header">Omegle Auto<span class="gui-counter" id="omegle-auto-counter">Sent: 0</span></div>
      <div class="gui-tabs">
        <div class="gui-tab active" data-tab="main">Main</div>
        <div class="gui-tab" data-tab="settings">Settings</div>
      </div>
      <div class="gui-page active" data-page="main">
        <label>Message (editable anytime)</label>
        <textarea id="omegle-auto-msg" placeholder="Type your message...">${(FALLBACK_MESSAGE || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</textarea>
        <div class="gui-toggle">
          <span>Repeat after cycle</span>
          <label class="toggle-switch">
            <input type="checkbox" id="omegle-auto-repeat" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="gui-buttons">
          <button class="btn-start" id="omegle-auto-start">Start</button>
          <button class="btn-stop" id="omegle-auto-stop">Stop</button>
        </div>
      </div>
      <div class="gui-page" data-page="settings">
        <div class="slider-row">
          <div class="slider-label"><span>Delay after typing</span><span class="slider-val" id="val-input">${DELAY_AFTER_INPUT_MS}ms</span></div>
          <input type="range" id="slider-input" min="100" max="3000" step="100" value="${DELAY_AFTER_INPUT_MS}">
        </div>
        <div class="slider-row">
          <div class="slider-label"><span>Delay after send</span><span class="slider-val" id="val-send">${DELAY_AFTER_SEND}ms</span></div>
          <input type="range" id="slider-send" min="100" max="3000" step="100" value="${DELAY_AFTER_SEND}">
        </div>
        <div class="slider-row">
          <div class="slider-label"><span>Delay after skip</span><span class="slider-val" id="val-skip">${DELAY_AFTER_SKIP}ms</span></div>
          <input type="range" id="slider-skip" min="200" max="5000" step="100" value="${DELAY_AFTER_SKIP}">
        </div>
        <div class="slider-row">
          <div class="slider-label"><span>Wait for next user</span><span class="slider-val" id="val-wait">${WAIT_FOR_NEXT_USER_MS}ms</span></div>
          <input type="range" id="slider-wait" min="1000" max="15000" step="500" value="${WAIT_FOR_NEXT_USER_MS}">
        </div>
      </div>
    `;

    guiMessageEl = panel.querySelector("#omegle-auto-msg");
    guiRepeatEl = panel.querySelector("#omegle-auto-repeat");
    const startBtn = panel.querySelector("#omegle-auto-start");
    const stopBtn = panel.querySelector("#omegle-auto-stop");

    startBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      log("Start button clicked");
      startBtn.disabled = true;
      stopBtn.disabled = false;
      try {
        runLoop();
      } catch (err) {
        log("Error: " + err.message);
        console.error(err);
        resetGuiButtons();
      }
    }, true);
    stopBtn.addEventListener("click", () => {
      stopOmegleAuto();
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });
    stopBtn.disabled = true;

    // Tabs
    const tabs = panel.querySelectorAll(".gui-tab");
    const pages = panel.querySelectorAll(".gui-page");
    tabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        tabs.forEach((t) => t.classList.remove("active"));
        pages.forEach((p) => p.classList.remove("active"));
        tab.classList.add("active");
        panel.querySelector('.gui-page[data-page="' + tab.dataset.tab + '"]').classList.add("active");
      });
    });

    // Speed sliders
    function bindSlider(sliderId, valId, setter) {
      const slider = panel.querySelector("#" + sliderId);
      const valEl = panel.querySelector("#" + valId);
      if (!slider || !valEl) return;
      slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        valEl.textContent = v >= 1000 ? (v / 1000).toFixed(1) + "s" : v + "ms";
        setter(v);
      });
    }
    bindSlider("slider-input", "val-input", (v) => { DELAY_AFTER_INPUT_MS = v; });
    bindSlider("slider-send",  "val-send",  (v) => { DELAY_AFTER_SEND = v; });
    bindSlider("slider-skip",  "val-skip",  (v) => { DELAY_AFTER_SKIP = v; });
    bindSlider("slider-wait",  "val-wait",  (v) => { WAIT_FOR_NEXT_USER_MS = v; });

    // Draggable
    const header = panel.querySelector(".gui-header");
    let isDragging = false, startX, startY, startLeft, startTop;
    header.addEventListener("mousedown", (e) => {
      if (e.target.tagName === "BUTTON") return;
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = panel.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      panel.style.left = startLeft + "px";
      panel.style.top = startTop + "px";
      panel.style.right = "auto";
    });
    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      panel.style.left = (startLeft + e.clientX - startX) + "px";
      panel.style.top = (startTop + e.clientY - startY) + "px";
    });
    document.addEventListener("mouseup", () => { isDragging = false; });

    document.body.appendChild(panel);
    log("GUI ready. Edit message and click Start.");
  }

  createGUI();
})();
